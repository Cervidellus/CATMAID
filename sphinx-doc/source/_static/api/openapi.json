{"swagger": "2.0", "info": {"title": "CATMAID API", "description": "", "version": ""}, "host": "localhost:8000", "schemes": ["http"], "paths": {"http://localhost:8000/api-token-auth/": {"post": {"operationId": "api-token-auth_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "data", "in": "body", "schema": {"type": "object", "properties": {"username": {"description": "Valid username for authentication", "type": "string"}, "password": {"description": "Valid password for authentication", "type": "string"}}, "required": ["username", "password"]}}], "consumes": ["application/json"], "tags": ["api-token-auth"]}}, "http://localhost:8000/apis/": {"get": {"operationId": "apis_list", "responses": {"200": {"description": ""}}, "parameters": [], "tags": ["apis"]}}, "http://localhost:8000/client/datastores/": {"get": {"operationId": "client_datastores_list", "responses": {"200": {"description": ""}}, "parameters": [], "tags": ["client"]}, "post": {"operationId": "client_datastores_create", "responses": {"201": {"description": ""}}, "parameters": [], "tags": ["client"]}}, "http://localhost:8000/client/datastores/{name}": {"delete": {"operationId": "client_datastores_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "name", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["client"]}}, "http://localhost:8000/client/datastores/{name}/": {"get": {"operationId": "client_datastores_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "name", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["client"]}, "put": {"operationId": "client_datastores_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "name", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["client"]}, "delete": {"operationId": "client_datastores_delete_0", "responses": {"204": {"description": ""}}, "parameters": [{"name": "name", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["client"]}}, "http://localhost:8000/ext/catmaidsynister/is-installed": {"get": {"operationId": "ext_catmaidsynister_is-installed_list", "responses": {"200": {"description": ""}}, "parameters": [], "description": "Check whether the extension catmaid-synister is installed.", "summary": "Check whether the extension catmaid-synister is installed.", "tags": ["ext"]}}, "http://localhost:8000/ext/catmaidsynister/{project_id}/connectors/{connector_id}/fetch-neurotransmitter": {"post": {"operationId": "ext_catmaidsynister_connectors_fetch-neurotransmitter_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "connector_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Try to retrieve neurotransmitter information from a remote service.", "summary": "Try to retrieve neurotransmitter information from a remote service.", "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/index": {"get": {"operationId": "ext_circuitmap_index_list", "responses": {"200": {"description": ""}}, "parameters": [], "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/is-installed": {"get": {"operationId": "ext_circuitmap_is-installed_list", "responses": {"200": {"description": ""}}, "parameters": [], "description": "Check whether the extension circuitmap is installed.", "summary": "Check whether the extension circuitmap is installed.", "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/test": {"get": {"operationId": "ext_circuitmap_test_list", "responses": {"200": {"description": ""}}, "parameters": [], "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/{project_id}/imports/": {"get": {"operationId": "ext_circuitmap_imports_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/{project_id}/imports/last-update": {"get": {"operationId": "ext_circuitmap_imports_last-update_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/{project_id}/imports/{import_id}/last-update": {"get": {"operationId": "ext_circuitmap_imports_last-update_list_0", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "import_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["ext"]}}, "http://localhost:8000/ext/circuitmap/{project_id}/synapses/fetch": {"post": {"operationId": "ext_circuitmap_synapses_fetch_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["ext"]}}, "http://localhost:8000/groups/": {"get": {"operationId": "groups_list", "responses": {"200": {"description": ""}}, "parameters": [], "tags": ["groups"]}}, "http://localhost:8000/projects/": {"get": {"operationId": "projects_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "has_tracing_data", "required": false, "in": "formData", "description": "Return only projects that have tracing data", "type": "string"}, {"name": "with_mirrors", "required": false, "in": "formData", "description": "Whether to include stack mirror data in the response.", "type": "string"}], "description": "List projects visible to the requesting user.", "summary": "List projects visible to the requesting user.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["projects"]}}, "http://localhost:8000/projects/export": {"get": {"operationId": "projects_export_list", "responses": {"200": {"description": ""}}, "parameters": [], "description": "Detailed list of projects visible to the requesting user.", "summary": "Detailed list of projects visible to the requesting user.", "tags": ["projects"]}}, "http://localhost:8000/{project_id}/analytics/broken-section-nodes": {"post": {"operationId": "analytics_broken-section-nodes_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "List of skeleton IDs to constrain tests on", "type": "string"}], "description": "List nodes that are located in a broken section.\n\nBroken secrions of all stacks linked to the current project are tested if\nthey contain any nodes. Stack orientatins are respected. Optionally, only\nparticular skeletons can be checked.", "summary": "List nodes that are located in a broken section.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["analytics"]}}, "http://localhost:8000/{project_id}/analytics/skeletons": {"post": {"operationId": "analytics_skeletons_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Find potentially problematic locations in a list of skeletons.", "summary": "Find potentially problematic locations in a list of skeletons.", "tags": ["analytics"]}}, "http://localhost:8000/{project_id}/annotations/": {"get": {"operationId": "annotations_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "annotations", "required": false, "in": "formData", "description": "A list of (meta) annotations with which which resulting annotations should be annotated with.", "type": "string"}, {"name": "annotates", "required": false, "in": "formData", "description": "A list of entity IDs (like annotations and neurons) that should be annotated by the result set.", "type": "string"}, {"name": "parallel_annotations", "required": false, "in": "formData", "description": "A list of annotation that have to be used alongside the result set.", "type": "string"}, {"name": "user_id", "required": false, "in": "formData", "description": "Result annotations have to be used by this user.", "type": "string"}, {"name": "neuron_id", "required": false, "in": "formData", "description": "Result annotations will annotate this neuron.", "type": "string"}, {"name": "skeleton_id", "required": false, "in": "formData", "description": "Result annotations will annotate the neuron modeled by this skeleton.", "type": "string"}, {"name": "ignored_annotations", "required": false, "in": "formData", "description": "A list of annotation names that will be excluded from the result set.", "type": "string"}, {"name": "if_modified_since", "required": false, "in": "formData", "description": "Works only if <simple> is True. Return 304 response if there is no\nnewer content with respect to the passed in UTC date in ISO format.\n", "type": "string"}], "description": "List annotations matching filtering criteria that are currently in use.\n\nThe result set is the intersection of annotations matching criteria (the\ncriteria are conjunctive) unless stated otherwise.", "summary": "List annotations matching filtering criteria that are currently in use.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}, "post": {"operationId": "annotations_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "annotations", "required": false, "in": "formData", "description": "A list of (meta) annotations with which which resulting annotations should be annotated with.", "type": "string"}, {"name": "annotates", "required": false, "in": "formData", "description": "A list of entity IDs (like annotations and neurons) that should be annotated by the result set.", "type": "string"}, {"name": "parallel_annotations", "required": false, "in": "formData", "description": "A list of annotation that have to be used alongside the result set.", "type": "string"}, {"name": "user_id", "required": false, "in": "formData", "description": "Result annotations have to be used by this user.", "type": "string"}, {"name": "neuron_id", "required": false, "in": "formData", "description": "Result annotations will annotate this neuron.", "type": "string"}, {"name": "skeleton_id", "required": false, "in": "formData", "description": "Result annotations will annotate the neuron modeled by this skeleton.", "type": "string"}, {"name": "ignored_annotations", "required": false, "in": "formData", "description": "A list of annotation names that will be excluded from the result set.", "type": "string"}, {"name": "if_modified_since", "required": false, "in": "formData", "description": "Works only if <simple> is True. Return 304 response if there is no\nnewer content with respect to the passed in UTC date in ISO format.\n", "type": "string"}], "description": "List annotations matching filtering criteria that are currently in use.\n\nThe result set is the intersection of annotations matching criteria (the\ncriteria are conjunctive) unless stated otherwise.", "summary": "List annotations matching filtering criteria that are currently in use.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}}, "http://localhost:8000/{project_id}/annotations/add-neuron-names": {"post": {"operationId": "annotations_add-neuron-names_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "A list of skeleton IDs to update", "type": "string"}, {"name": "entity_ids", "required": false, "in": "formData", "description": "A list of target entity IDs to update", "type": "string"}], "description": "Add missing neuron name annotations.\n\nTo each passed in neuron, a list of neuron IDs and/or skelton IDs, the\nneuron name stored in the neuron's base name is added as annotation. Each\nneuron name annotation is meta-annotated with a \"Name\" annotation.", "summary": "Add missing neuron name annotations.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}}, "http://localhost:8000/{project_id}/annotations/forskeletons": {"post": {"operationId": "annotations_forskeletons_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "A list of skeleton IDs which are annotated by the resulting annotations.", "type": "string"}], "description": "Get annotations and who used them for a set of skeletons.\n\nThis method focuses only on annotations linked to skeletons and is likely to\nbe faster than the general query. Returns an object with two fields:\n\"annotations\", which is itself an object with annotation IDs as fields,\ngiving access to the corresponding annotation names. And the field\n\"skeletons\" is also an object, mapping skeleton IDs to lists of\nannotation-annotator ID pairs. Also, as JSON separator a colon is used\ninstead of a comma.", "summary": "Get annotations and who used them for a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}}, "http://localhost:8000/{project_id}/annotations/query": {"post": {"operationId": "annotations_query_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "object_ids", "required": false, "in": "formData", "description": "A list of object IDs for which annotations should be returned.", "type": "string"}], "description": "Query annotations linked to a list of objects.\n\nThese objects can for instance be neurons, annotations or stack groups. From\na database perspective, these objects are class instances.\n\nReturned is an object with the fields \"entities\" and \"annotations\". The\nformer is an object mapping an entity ID to a list of annotations. Each\nannotation is represented by an object containing its \"id\" and \"uid\", the\nuser who annotated it. The latter maps annotation IDs to annotation names.\nFor instance::\n\n{ \"entities\": { \"42\": [{id: 1, uid: 12}, {id: 3, uid: 14}] }, \"annotations\": { 12: \"example1\", 14: \"example2\" } }", "summary": "Query annotations linked to a list of objects.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}}, "http://localhost:8000/{project_id}/annotations/query-targets": {"post": {"operationId": "annotations_query-targets_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "name", "required": false, "in": "formData", "description": "The name (or a part of it) of result elements.", "type": "string"}, {"name": "name_exact", "required": false, "in": "formData", "description": "Whether the name has to match exactly or can be a part of the result\nname. This is typically faster than using a regular expression.\nFalse by default.\n", "type": "string"}, {"name": "name_case_sensitive", "required": false, "in": "formData", "description": "Whether the name has to match the exact letter case provided. False\nby default.\n", "type": "string"}, {"name": "annotated_by", "required": false, "in": "formData", "description": "A result element was annotated by a user with this ID.", "type": "string"}, {"name": "annotation_date_start", "required": false, "in": "query", "description": "The earliest YYYY-MM-DD date result elements have been annotated at.", "type": "string"}, {"name": "annotation_date_end", "required": false, "in": "query", "description": "The latest YYYY-MM-DD date result elements have been annotated at.", "type": "string"}, {"name": "annotated_with", "required": false, "in": "formData", "description": "A comma separated list of annotation IDs which all annotate the\nresult elements.\n", "type": "string"}, {"name": "not_annotated_with", "required": false, "in": "formData", "description": "A comma separated list of annotation IDs which don't annotate the\nresult elements.\n", "type": "string"}, {"name": "sub_annotated_with", "required": false, "in": "formData", "description": "A comma separated list of annotation IDs that are contained\nin either 'annotated_with' or 'not_annotated_with' that get expanded to\nalso include their sub-annotations in the query (of which then at\nleast one has to match inclusion or exclusion respectively).\n", "type": "string"}, {"name": "with_annotations", "required": false, "in": "formData", "description": "Indicate if annotations of result elements should be returned.", "type": "string"}, {"name": "types", "required": false, "in": "formData", "description": "Allowed result types. Multple types can be passed with multiple\nparameters. Defaults to 'neuron' and 'annotation'.\n", "type": "string"}, {"name": "sort_by", "required": false, "in": "formData", "description": "Indicates how results are sorted.", "type": "string"}, {"name": "sort_dir", "required": false, "in": "formData", "description": "Indicates sorting direction.", "type": "string"}, {"name": "range_start", "required": false, "in": "formData", "description": "The first result element index.", "type": "string"}, {"name": "range_length", "required": false, "in": "formData", "description": "The number of results", "type": "string"}, {"name": "annotation_reference", "required": false, "in": "formData", "description": "Whether annoation references are IDs or names, can be 'id' or 'name.", "type": "string"}, {"name": "with_timestamps", "required": false, "in": "formData", "description": "Whether to return also the annotation time for each entity.", "type": "string"}, {"name": "import_only", "required": false, "in": "formData", "description": "Whether and how only skeletons that contain imported fragments\nshould be returned. If set to 'partial', only skeletons that have at\nleast one imported node in them are returned. If set to 'full', only\nskeletons that are fully imported are returned. Not set by default.\n", "type": "string"}], "description": "Query entities based on various constraints\n\nEntities are objects that can be referenced within CATMAID's semantic\nspace, e.g. neurons, annotations or stack groups. This API allows to query\nthem, mainly by annotations that have been used with them. Multiple\nannotation parameters can be used to combine different annotation sets with\nAND. Elements of one annotation parameter are combined with OR.", "summary": "Query entities based on various constraints", "consumes": ["application/x-www-form-urlencoded"], "tags": ["annotations"]}}, "http://localhost:8000/{project_id}/connector/list/linked-to-nodes": {"post": {"operationId": "connector_list_linked-to-nodes_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in.", "type": "string"}, {"name": "treenode_ids", "required": true, "in": "formData", "description": "Treenode IDs that result nodes are connected to.", "type": "string"}], "description": "Get a list of connectors that are linked to a set of treenodes.", "summary": "Get a list of connectors that are linked to a set of treenodes.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connector"]}}, "http://localhost:8000/{project_id}/connectors/": {"post": {"operationId": "connectors_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of connectors", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Skeletons linked to connectors", "type": "string"}, {"name": "tags", "required": false, "in": "formData", "description": "Require a set of tags", "type": "string"}, {"name": "relation_type", "required": false, "in": "formData", "description": "Relation of linked skeletons to connector.", "type": "string"}, {"name": "without_relation_types", "required": false, "in": "formData", "description": "Relations to linked skeletons that connectors must not have.\n", "type": "string"}, {"name": "with_tags", "required": false, "in": "formData", "description": "If connector tags should be fetched", "type": "string"}, {"name": "with_partners", "required": false, "in": "formData", "description": "If partner node and link information should be fetched", "type": "string"}], "description": "Get a collection of connectors.\n\nThe `connectors` field of the returned object contains a list of all result\nnodes, each represented as a list of the form:\n\n`[id, x, y, z, confidence, creator_id, editor_id, creation_time, edition_time]`\n\nBoth edition time and creation time are returned as UTC epoch values. If\ntags are requested, the `tags` field of the response object will contain a\nmapping of connector IDs versus tag lists. If partners are requested, the\n`partners` field of the response object will contain a mapping of connector\nIDs versus lists of partner links. Each partner link is an array of the\nfollowing format:\n\n`[link_id, treenode_id, skeleton_id, relation_id, confidence]`\n\nIf both `skeleton_ids` and `relation_type` are used, the linked skeletons\nneed to be linked by the specified relation. Without `relation_type`,\nlinked skeletons can have any relation and without `skeleton_ids` a\nconnector needs to have a least one link with the specified relation.", "summary": "Get a collection of connectors.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/connectors/in-bounding-box": {"get": {"operationId": "connectors_in-bounding-box_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "limit", "required": false, "in": "formData", "description": "Limit the number of returned nodes.\n", "type": "string"}, {"name": "minx", "required": true, "in": "formData", "description": "Minimum world space X coordinate\n", "type": "string"}, {"name": "miny", "required": true, "in": "formData", "description": "Minimum world space Y coordinate\n", "type": "string"}, {"name": "minz", "required": true, "in": "formData", "description": "Minimum world space Z coordinate\n", "type": "string"}, {"name": "maxx", "required": true, "in": "formData", "description": "Maximum world space X coordinate\n", "type": "string"}, {"name": "maxy", "required": true, "in": "formData", "description": "Maximum world space Y coordinate\n", "type": "string"}, {"name": "maxz", "required": true, "in": "formData", "description": "Maximum world space Z coordinate\n", "type": "string"}, {"name": "with_locations", "required": false, "in": "formData", "description": "Whether to return the location of each connector.\n", "type": "string"}, {"name": "with_links", "required": false, "in": "formData", "description": "Whether to return every individual link or null for unlinked connectors\n(if part of response).\n", "type": "string"}, {"name": "only_linked", "required": false, "in": "formData", "description": "Whether to return only connectors with linked treenodes. By default all\nconnectors are returned and link information is null for unlinked nodes.\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Skeletons linked to connectors", "type": "string"}], "description": "Get a list of all connector nodes that intersect with the passed in\nbounding box.", "summary": "Get a list of all connector nodes that intersect with the passed in", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}, "post": {"operationId": "connectors_in-bounding-box_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "limit", "required": false, "in": "formData", "description": "Limit the number of returned nodes.\n", "type": "string"}, {"name": "minx", "required": true, "in": "formData", "description": "Minimum world space X coordinate\n", "type": "string"}, {"name": "miny", "required": true, "in": "formData", "description": "Minimum world space Y coordinate\n", "type": "string"}, {"name": "minz", "required": true, "in": "formData", "description": "Minimum world space Z coordinate\n", "type": "string"}, {"name": "maxx", "required": true, "in": "formData", "description": "Maximum world space X coordinate\n", "type": "string"}, {"name": "maxy", "required": true, "in": "formData", "description": "Maximum world space Y coordinate\n", "type": "string"}, {"name": "maxz", "required": true, "in": "formData", "description": "Maximum world space Z coordinate\n", "type": "string"}, {"name": "with_locations", "required": false, "in": "formData", "description": "Whether to return the location of each connector.\n", "type": "string"}, {"name": "with_links", "required": false, "in": "formData", "description": "Whether to return every individual link or null for unlinked connectors\n(if part of response).\n", "type": "string"}, {"name": "only_linked", "required": false, "in": "formData", "description": "Whether to return only connectors with linked treenodes. By default all\nconnectors are returned and link information is null for unlinked nodes.\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Skeletons linked to connectors", "type": "string"}], "description": "Get a list of all connector nodes that intersect with the passed in\nbounding box.", "summary": "Get a list of all connector nodes that intersect with the passed in", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/connectors/links/": {"get": {"operationId": "connectors_links_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": true, "in": "formData", "description": "Skeletons to list connectors for", "type": "string"}, {"name": "relation_type", "required": true, "in": "formData", "description": "Relation of listed connector links", "type": "string"}, {"name": "with_tags", "required": false, "in": "formData", "description": "If connector tags should be fetched", "type": "string"}], "description": "Get connectors linked to a set of skeletons.\n\nThe result data set includes information about linked connectors on a given\ninput set of skeletons. These links are further constrained by relation\ntype, with currently support available for: postsynaptic_to,\npresynaptic_to, abutting, gapjunction_with, tightjunction_with,\ndesmosome_with.\n\nReturned is an object containing an array of links to connectors and a set\nof tags for all connectors found (if not disabled). The link array contains\none array per connector link with the following content: [Linked skeleton ID,\nConnector ID, Connector X, Connector Y, Connector Z, Link confidence, Link\ncreator ID, Linked treenode ID, Link edit time].\n\nA POST handler is able to accept large lists of skeleton IDs.", "summary": "Get connectors linked to a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}, "post": {"operationId": "connectors_links_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": true, "in": "formData", "description": "Skeletons to list connectors for", "type": "string"}, {"name": "relation_type", "required": true, "in": "formData", "description": "Relation of listed connector links", "type": "string"}, {"name": "with_tags", "required": false, "in": "formData", "description": "If connector tags should be fetched", "type": "string"}], "description": "Get connectors linked to a set of skeletons.\n\nThe result data set includes information about linked connectors on a given\ninput set of skeletons. These links are further constrained by relation\ntype, with currently support available for: postsynaptic_to,\npresynaptic_to, abutting, gapjunction_with, tightjunction_with,\ndesmosome_with.\n\nReturned is an object containing an array of links to connectors and a set\nof tags for all connectors found (if not disabled). The link array contains\none array per connector link with the following content: [Linked skeleton ID,\nConnector ID, Connector X, Connector Y, Connector Z, Link confidence, Link\ncreator ID, Linked treenode ID, Link edit time].\n\nA POST handler is able to accept large lists of skeleton IDs.", "summary": "Get connectors linked to a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/connectors/types/": {"get": {"operationId": "connectors_types_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get a list of available connector types.\n\nReturns a list of all available connector link types in a project. Each\nlist element consists of an object with the following fields: type,\nrelation, relation_id.", "summary": "Get a list of available connector types.", "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/connectors/user-info": {"get": {"operationId": "connectors_user-info_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project of connectors", "type": "string"}, {"name": "treenode_id", "required": true, "in": "formData", "description": "The treenode, the connector is linked to", "type": "string"}, {"name": "connector_id", "required": true, "in": "formData", "description": "The connector, the treenode is linked to", "type": "string"}, {"name": "relation_id", "required": false, "in": "formData", "description": "The relation ID of the link, can be used instead of relation_name", "type": "string"}, {"name": "relation_name", "required": false, "in": "formData", "description": "The relation name of the link, can be used instead of relation_id", "type": "string"}], "description": "Return information on a treenode connector edge.\n\nReturns a JSON array with elements representing information on the matched\nlinks. They have the following form:\n\n{ \"user\": ..., \"creaetion_time\": ..., \"edition_time\": ... }\n\nDeveloper node: This function is called often (every connector mouseover)\nand should therefore be as fast as possible. Analogous to user_info for\ntreenodes and connectors.", "summary": "Return information on a treenode connector edge.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/connectors/{connector_id}/": {"get": {"operationId": "connectors_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "connector_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get detailed information on a connector and its partners", "summary": "Get detailed information on a connector and its partners", "tags": ["connectors"]}}, "http://localhost:8000/{project_id}/fork": {"post": {"operationId": "fork_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "name", "required": true, "in": "formData", "description": "Name of new project", "type": "string"}], "description": "Attempt to create a new project based on the passed in project ID.", "summary": "Attempt to create a new project based on the passed in project ID.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["fork"]}}, "http://localhost:8000/{project_id}/graph/circlesofhell": {"post": {"operationId": "graph_circlesofhell_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to start expanding from.", "type": "string"}, {"name": "n_circles", "required": false, "in": "formData", "description": "(Optional) The numbers of recursive expansions.", "type": "string"}, {"name": "allowed_connector_ids[]", "required": false, "in": "formData", "description": "(Optional) IDs of connector nodes that are allowed to be used for expansion.", "type": "string"}], "description": "Given a set of one or more skeleton IDs, find all skeletons that connect\nthem (n_circles=1), or that connect to others that connect them (n_circles=2), etc.\nReturns a list of unique skeleton IDs that exclude the ones provided as argument.", "summary": "Given a set of one or more skeleton IDs, find all skeletons that connect", "consumes": ["application/x-www-form-urlencoded"], "tags": ["graph"]}}, "http://localhost:8000/{project_id}/interpolatable-sections/": {"get": {"operationId": "interpolatable-sections_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get all section locations for all orientations.", "summary": "Get all section locations for all orientations.", "tags": ["interpolatable-sections"]}}, "http://localhost:8000/{project_id}/labels/": {"get": {"operationId": "labels_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project containing node of interest", "type": "string"}], "description": "List all labels (front-end node *tags*) in use.", "summary": "List all labels (front-end node *tags*) in use.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["labels"]}}, "http://localhost:8000/{project_id}/labels/detail": {"get": {"operationId": "labels_detail_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project containing node of interest", "type": "string"}], "description": "List all labels (front-end node *tags*) in use alongside their IDs.", "summary": "List all labels (front-end node *tags*) in use alongside their IDs.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["labels"]}}, "http://localhost:8000/{project_id}/labels/stats": {"get": {"operationId": "labels_stats_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project from which to get label stats", "type": "string"}], "description": "Get usage statistics of node labels.", "summary": "Get usage statistics of node labels.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["labels"]}}, "http://localhost:8000/{project_id}/labels/{node_type}/{node_id}/": {"get": {"operationId": "labels_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project containing node of interest", "type": "string"}, {"name": "node_type", "required": true, "in": "formData", "description": "Either 'connector', 'treenode' or 'location'", "type": "string"}, {"name": "node_id", "required": true, "in": "formData", "description": "ID of node to list labels for", "type": "string"}], "description": "List all labels (front-end node *tags*) attached to a particular node.", "summary": "List all labels (front-end node *tags*) attached to a particular node.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["labels"]}}, "http://localhost:8000/{project_id}/landmarks/": {"get": {"operationId": "landmarks_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "put": {"operationId": "landmarks_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "delete": {"operationId": "landmarks_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/": {"get": {"operationId": "landmarks_groups_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "put": {"operationId": "landmarks_groups_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/import": {"post": {"operationId": "landmarks_groups_import_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/links/": {"put": {"operationId": "landmarks_groups_links_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/links/{link_id}/": {"delete": {"operationId": "landmarks_groups_links_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "link_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/materialize": {"post": {"operationId": "landmarks_groups_materialize_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/{landmarkgroup_id}/": {"get": {"operationId": "landmarks_groups_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "post": {"operationId": "landmarks_groups_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "delete": {"operationId": "landmarks_groups_delete_0", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/{landmarkgroup_id}/locations/{location_id}/": {"put": {"operationId": "landmarks_groups_locations_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "location_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "delete": {"operationId": "landmarks_groups_locations_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "location_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/groups/{landmarkgroup_id}/transitively-linked": {"get": {"operationId": "landmarks_groups_transitively-linked_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmarkgroup_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/{landmark_id}/": {"get": {"operationId": "landmarks_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "post": {"operationId": "landmarks_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}, "delete": {"operationId": "landmarks_delete_0", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/{landmark_id}/groups/{group_id}/": {"delete": {"operationId": "landmarks_groups_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "group_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/{landmark_id}/locations/": {"put": {"operationId": "landmarks_locations_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/landmarks/{landmark_id}/locations/{location_id}/": {"delete": {"operationId": "landmarks_locations_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "landmark_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "location_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["landmarks"]}}, "http://localhost:8000/{project_id}/neuron/{neuron_id}/get-all-skeletons": {"get": {"operationId": "neuron_get-all-skeletons_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "neuron_id", "required": true, "in": "path", "description": "ID of neuron to get skeletons for", "type": "string"}], "description": "Get a list of all skeleton IDs linked to the passed in neuron.", "summary": "Get a list of all skeleton IDs linked to the passed in neuron.", "tags": ["neuron"]}}, "http://localhost:8000/{project_id}/neurons/": {"get": {"operationId": "neurons_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "created_by", "required": false, "in": "query", "description": "Filter for user ID of the neurons' creator.", "type": "string"}, {"name": "reviewed_by", "required": false, "in": "query", "description": "Filter for user ID of the neurons' reviewer.", "type": "string"}, {"name": "from_date", "required": false, "in": "query", "description": "Filter for neurons with nodes created after this date.", "type": "string"}, {"name": "to_date", "required": false, "in": "query", "description": "Filter for neurons with nodes created before this date.", "type": "string"}, {"name": "nodecount_gt", "required": false, "in": "query", "description": "Filter for neurons with more nodes than this threshold. Removes\nall other criteria.\n", "type": "string"}], "description": "List neurons matching filtering criteria.\n\nThe result set is the intersection of neurons matching criteria (the\ncriteria are conjunctive) unless stated otherwise.", "summary": "List neurons matching filtering criteria.", "tags": ["neurons"]}}, "http://localhost:8000/{project_id}/neurons/all-skeletons": {"post": {"operationId": "neurons_all-skeletons_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "neuron_ids", "required": true, "in": "path", "description": "IDs of neurons to get skeletons for", "type": "string"}], "description": "Find all skeleton IDs linked to the passed in neurons.\n\nA map", "summary": "Find all skeleton IDs linked to the passed in neurons.", "tags": ["neurons"]}}, "http://localhost:8000/{project_id}/neurons/from-models": {"post": {"operationId": "neurons_from-models_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "model_ids[]", "required": true, "in": "formData", "description": "IDs of models to find neurons for (e.g. skeleton IDs)", "type": "string"}], "description": "Retrieve neuron IDs modeled by particular entities, eg skeletons.\n\nFrom a list of source entities (class instances), the IDs of all modeled\nneurons are returned. There are currently only skeletons that model neurons.", "summary": "Retrieve neuron IDs modeled by particular entities, eg skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["neurons"]}}, "http://localhost:8000/{project_id}/neurons/rename": {"post": {"operationId": "neurons_rename_create_0", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "neuron_names", "required": true, "in": "formData", "description": "A list of two-element tuples, containing of neuron ID and new name each.", "type": "string"}], "description": "Rename a neuron.\n\nIf a neuron is not locked by a user on which the current user has no\npermission, the name of neuron can be changed through this endpoint. Neuron\nnames are currently not allowed to contain pipe characters (\"|\").", "summary": "Rename a neuron.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["neurons"]}}, "http://localhost:8000/{project_id}/neurons/{neuron_id}/rename": {"post": {"operationId": "neurons_rename_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "neuron_id", "required": true, "in": "path", "description": "ID of neuron to rename", "type": "string"}, {"name": "name", "required": true, "in": "formData", "description": "New name of the neuron", "type": "string"}], "description": "Rename a neuron.\n\nIf a neuron is not locked by a user on which the current user has no\npermission, the name of neuron can be changed through this endpoint. Neuron\nnames are currently not allowed to contain pipe characters (\"|\").", "summary": "Rename a neuron.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["neurons"]}}, "http://localhost:8000/{project_id}/nodes/": {"post": {"operationId": "nodes_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_ids", "required": false, "in": "formData", "description": "Whether linked connectors should be returned.\n", "type": "string"}, {"name": "connector_ids", "required": false, "in": "formData", "description": "Whether tags should be returned.\n", "type": "string"}, {"name": "limit", "required": false, "in": "formData", "description": "Limit the number of returned nodes.\n", "type": "string"}, {"name": "left", "required": true, "in": "formData", "description": "Minimum world space X coordinate\n", "type": "string"}, {"name": "top", "required": true, "in": "formData", "description": "Minimum world space Y coordinate\n", "type": "string"}, {"name": "z1", "required": true, "in": "formData", "description": "Minimum world space Z coordinate\n", "type": "string"}, {"name": "right", "required": true, "in": "formData", "description": "Maximum world space X coordinate\n", "type": "string"}, {"name": "bottom", "required": true, "in": "formData", "description": "Maximum world space Y coordinate\n", "type": "string"}, {"name": "z2", "required": true, "in": "formData", "description": "Maximum world space Z coordinate\n", "type": "string"}, {"name": "format", "required": false, "in": "formData", "description": "Either \"json\" (default) or \"msgpack\", optional.\n", "type": "string"}, {"name": "with_relation_map", "required": false, "in": "formData", "description": "Whether an ID to name mapping for the used relations should be included\nand which extent it should have.\n", "type": "string"}, {"name": "with_origin", "required": false, "in": "formData", "description": "Whether the origin for each skeleton should be looked up and returned.\nThis will show which skeletons are imported.\n", "type": "string"}, {"name": "n_largest_skeletons_limit", "required": false, "in": "formData", "description": "Maximum number of the largest skeletons in view\n", "type": "string"}, {"name": "n_last_edited_skeletons_limit", "required": false, "in": "formData", "description": "Maximum number of most recently edited skeletons.\n", "type": "string"}, {"name": "hidden_last_editor_id", "required": false, "in": "formData", "description": "No nodes edited last by this user will be retuned.\n", "type": "string"}, {"name": "min_skeleton_length", "required": false, "in": "formData", "description": "Optional minimum skeleton length, no returned node is of a shorter\nskeleton.\n", "type": "string"}, {"name": "order", "required": false, "in": "formData", "description": "Either empty, cable-asc or cable-desc. Will return in a particular\norder. By default, no ordering is applied.\n", "type": "string"}], "description": "Retrieve all nodes intersecting a bounding box\n\nThe intersection bounding box is defined in terms of its minimum and\nmaximum project space coordinates. The number of returned nodes can be\nlimited to constrain query execution time. Optionally, lists of treenodes\nand connector IDs can be provided to make sure they are included in the\nresult set, regardless of intersection.\n\nReturned is an array with five entries, plus optionally a sixth one\n\n[[treenodes], [connectors], {labels}, node_limit_reached, {relation_map}, {exstraNodes}]\n\nThe list of treenodes has elements of this form:\n\n[id, parent_id, location_x, location_y, location_z, confidence, radius, skeleton_id, edition_time, user_id]\n\nThe list connectors has elements of this form:\n\n[id, location_x, location_y, location_z, confidence, edition_time, user_id, [partners]]\n\nThe partners arrary represents linked partner nodes, each one represented like this:\n\n[treenode_id, relation_id, link_confidence, link_edition_time, link_id]\n\nIf labels are returned, they are represented as an object of the following\nform, with the labels just being simple strings:\n\n{treenode_id: [labels]}\n\nThe fourth top level entry, node_limit_reached, is a boolean that\nrepresents if there are more nodes available than the ones returned.\n\nWith the last top level element returned the present connector linked\nrelations are mapped to their textural representations:\n\n{relation_id: relation_name}", "summary": "Retrieve all nodes intersecting a bounding box", "consumes": ["application/x-www-form-urlencoded"], "tags": ["nodes"]}}, "http://localhost:8000/{project_id}/nodes/find-labels": {"post": {"operationId": "nodes_find-labels_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "x", "required": true, "in": "formData", "description": "X coordinate of the distance reference in project space.", "type": "string"}, {"name": "y", "required": true, "in": "formData", "description": "Y coordinate of the distance reference in project space.", "type": "string"}, {"name": "z", "required": true, "in": "formData", "description": "Z coordinate of the distance reference in project space.", "type": "string"}, {"name": "label_regex", "required": true, "in": "formData", "description": "Regular expression query to match labels", "type": "string"}], "description": "List nodes with labels matching a query, ordered by distance.\n\nFind nodes with labels (front-end node tags) matching a regular\nexpression, sort them by ascending distance from a reference location, and\nreturn the result. Returns at most 50 nodes.", "summary": "List nodes with labels matching a query, ordered by distance.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["nodes"]}}, "http://localhost:8000/{project_id}/nodes/location": {"post": {"operationId": "nodes_location_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "node_ids", "required": true, "in": "formData", "description": "A list of node IDs to get the location for", "type": "string"}], "description": "Get locations for a particular set of nodes in a project.\n\nA list of lists is returned. Each inner list represents one location and\nhast the following format: [id, x, y, z].", "summary": "Get locations for a particular set of nodes in a project.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["nodes"]}}, "http://localhost:8000/{project_id}/nodes/most-recent": {"get": {"operationId": "nodes_most-recent_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in.", "type": "string"}, {"name": "skeleton_id", "required": false, "in": "formData", "description": "(optional) Skeleton for which to retrieve last edited node.\n", "type": "string"}, {"name": "user_id", "required": false, "in": "formData", "description": "(optional) User of which to retrieve last edited node.\n", "type": "string"}], "description": "Retrieve the last edited node.\n\nWithout any further parameters, this will retrieve the node last edited on\nany skeleton by any user. This can be further constrained by skeleton and\nuser.", "summary": "Retrieve the last edited node.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["nodes"]}}, "http://localhost:8000/{project_id}/nodes/nearest": {"get": {"operationId": "nodes_nearest_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in.", "type": "string"}, {"name": "x", "required": true, "in": "formData", "description": "X coordinate of query location.", "type": "string"}, {"name": "y", "required": true, "in": "formData", "description": "X coordinate of query location.", "type": "string"}, {"name": "z", "required": true, "in": "formData", "description": "Z coordinate of query location.", "type": "string"}, {"name": "skeleton_id", "required": false, "in": "formData", "description": "Result treenode has to be in this skeleton.", "type": "string"}, {"name": "neuron_id", "required": false, "in": "formData", "description": "Alternative to skeleton_id. Result treenode has to be in\nthis neuron\n", "type": "string"}], "description": "Find the closest node in a skeleton relative to a passed in location.\n\nIf a skeleton ID or neuron id is passed in as well, the nearest node in the\nrespective skeleton is returned.", "summary": "Find the closest node in a skeleton relative to a passed in location.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["nodes"]}}, "http://localhost:8000/{project_id}/origins/": {"get": {"operationId": "origins_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["origins"]}}, "http://localhost:8000/{project_id}/pointclouds/": {"get": {"operationId": "pointclouds_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}, "post": {"operationId": "pointclouds_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}, "put": {"operationId": "pointclouds_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}}, "http://localhost:8000/{project_id}/pointclouds/{pointcloud_id}/": {"get": {"operationId": "pointclouds_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "pointcloud_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}, "delete": {"operationId": "pointclouds_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "pointcloud_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}}, "http://localhost:8000/{project_id}/pointclouds/{pointcloud_id}/images/{image_id}/": {"get": {"operationId": "pointclouds_images_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "pointcloud_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "image_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointclouds"]}}, "http://localhost:8000/{project_id}/points/": {"get": {"operationId": "points_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["points"]}, "put": {"operationId": "points_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["points"]}}, "http://localhost:8000/{project_id}/points/{point_id}/": {"get": {"operationId": "points_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "point_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["points"]}, "post": {"operationId": "points_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "point_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["points"]}, "delete": {"operationId": "points_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "point_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["points"]}}, "http://localhost:8000/{project_id}/pointsets/": {"get": {"operationId": "pointsets_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointsets"]}, "post": {"operationId": "pointsets_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointsets"]}}, "http://localhost:8000/{project_id}/pointsets/{pointset_id}/": {"get": {"operationId": "pointsets_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "pointset_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["pointsets"]}}, "http://localhost:8000/{project_id}/samplers/": {"get": {"operationId": "samplers_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Optional skeleton IDs to constrain result set to.", "type": "string"}, {"name": "with_domains", "required": false, "in": "formData", "description": "Optional flag to include all domains of all result sampler results.", "type": "string"}, {"name": "with_intervals", "required": false, "in": "formData", "description": "Optional flag to include all intervals of all domains. Implies with_domains.", "type": "string"}], "description": "Get a collection of available samplers.\n\nOptionally, the \"skeleton_ids\" parameter can provide a list of skeleton IDs.\nIf this is the case, only samplers for the respective skeletons are returned.", "summary": "Get a collection of available samplers.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/add": {"post": {"operationId": "samplers_add_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "formData", "description": "Skeleton this sampelr is for", "type": "string"}, {"name": "interval_length", "required": true, "in": "formData", "description": "Length of a intervals with domains (nm).", "type": "string"}, {"name": "interval_error", "required": false, "in": "formData", "description": "Maximum allowed error for a single interval.", "type": "string"}, {"name": "review_required", "required": true, "in": "formData", "description": "Whether reviews should be enforced in this sampler", "type": "string"}, {"name": "create_interval_boundaries", "required": true, "in": "formData", "description": "Whether new nodes for interval boundaries should be created.", "type": "string"}, {"name": "leaf_segment_handling", "required": false, "in": "formData", "description": "How leaf segments should be handled, can be 'ignore', 'merge' or 'short-interval'.", "type": "string"}, {"name": "merge_limit", "required": false, "in": "formData", "description": "A leaf handling option for merge-or-create mode. A value between 0 and 1 representing the interval length ratio up to which a merge is allowed.", "type": "string"}], "description": "Create a new sampler for a skeleton.", "summary": "Create a new sampler for a skeleton.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/connectors/": {"get": {"operationId": "samplers_connectors_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "interval_id", "required": false, "in": "formData", "description": "The interval all results should be part of", "type": "string"}, {"name": "connector_id", "required": false, "in": "formData", "description": "The connector to get sampler information for", "type": "string"}, {"name": "state_id", "required": false, "in": "formData", "description": "The state all result sets have to have.", "type": "string"}], "description": "Get a list of connectors that already have a state associated with them.\n\nIf a connector is not part of this list it is implicetely assumed to be in\nan \"untouched\" state.", "summary": "Get a list of connectors that already have a state associated with them.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/connectors/states/": {"get": {"operationId": "samplers_connectors_states_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get a list of all available connectors states and their IDs.", "summary": "Get a list of all available connectors states and their IDs.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/intervals/states/": {"get": {"operationId": "samplers_domains_intervals_states_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get a list of all available interval states.", "summary": "Get a list of all available interval states.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/intervals/{interval_id}/connectors/{connector_id}/set-state": {"post": {"operationId": "samplers_domains_intervals_connectors_set-state_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "interval_id", "required": true, "in": "formData", "description": "Interval the connector is part of", "type": "string"}, {"name": "connector_id", "required": true, "in": "formData", "description": "Connector to set state of", "type": "string"}, {"name": "state_id", "required": true, "in": "formData", "description": "The new state", "type": "string"}], "description": "Set state of sampler connector", "summary": "Set state of sampler connector", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/intervals/{interval_id}/details": {"get": {"operationId": "samplers_domains_intervals_details_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "interval_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get details on a particular interval.", "summary": "Get details on a particular interval.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/intervals/{interval_id}/set-state": {"post": {"operationId": "samplers_domains_intervals_set-state_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "interval_id", "required": true, "in": "formData", "description": "Interval to update state of", "type": "string"}], "description": "Set state of an interval.", "summary": "Set state of an interval.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/types/": {"get": {"operationId": "samplers_domains_types_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get a list of all available domain types.", "summary": "Get a list of all available domain types.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/{domain_id}/details": {"get": {"operationId": "samplers_domains_details_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "domain_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get details on a particular domain.", "summary": "Get details on a particular domain.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/{domain_id}/intervals/": {"get": {"operationId": "samplers_domains_intervals_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "domain_id", "required": true, "in": "formData", "description": "Domain to list intervals for", "type": "string"}], "description": "Get a collection of available sampler domains intervals.", "summary": "Get a collection of available sampler domains intervals.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/domains/{domain_id}/intervals/add-all": {"post": {"operationId": "samplers_domains_intervals_add-all_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "domain_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Create all intervals in a particular domain.", "summary": "Create all intervals in a particular domain.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/states/": {"get": {"operationId": "samplers_states_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get a list of all available sampler states and their IDs.", "summary": "Get a list of all available sampler states and their IDs.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/{sampler_id}/": {"get": {"operationId": "samplers_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["samplers"]}, "post": {"operationId": "samplers_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/{sampler_id}/delete": {"post": {"operationId": "samplers_delete_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "delete_created_nodes", "required": false, "in": "formData", "description": "Optional flag to disable automatic removal of untouched\nnodes created for this sampler's intervals.\n", "type": "string"}], "description": "Delete a sampler if permissions allow it.\n\nIf the sampler was created with allowing the creation of new boundary nodes,\nthese nodes are removed by default if they have not been modified since\ntheir insertion. This can optionally be disabled using the\n<delete_created_nodes> parameter.", "summary": "Delete a sampler if permissions allow it.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/{sampler_id}/domains/": {"get": {"operationId": "samplers_domains_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "formData", "description": "Sampler to list domains for", "type": "string"}], "description": "Get a collection of available sampler domains.", "summary": "Get a collection of available sampler domains.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/{sampler_id}/domains/add": {"post": {"operationId": "samplers_domains_add_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "formData", "description": "Sampeler the new domain is part of", "type": "string"}, {"name": "domain_type_id", "required": true, "in": "formData", "description": "The type of the new domain", "type": "string"}, {"name": "start_node_id", "required": true, "in": "formData", "description": "Start node of domain", "type": "string"}, {"name": "end_node_ids", "required": true, "in": "formData", "description": "A list of all end nodes for the new domain", "type": "string"}, {"name": "parent_interval_id", "required": false, "in": "formData", "description": "Optional parent inerval ID.", "type": "string"}], "description": "Create a new domain for a sampler.", "summary": "Create a new domain for a sampler.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/samplers/{sampler_id}/domains/add-all": {"post": {"operationId": "samplers_domains_add-all_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "sampler_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Create a new domain for a sampler.", "summary": "Create a new domain for a sampler.", "tags": ["samplers"]}}, "http://localhost:8000/{project_id}/similarity/configs/": {"get": {"operationId": "similarity_configs_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}, "put": {"operationId": "similarity_configs_update", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}}, "http://localhost:8000/{project_id}/similarity/configs/{config_id}/": {"get": {"operationId": "similarity_configs_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "config_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}, "delete": {"operationId": "similarity_configs_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "config_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}}, "http://localhost:8000/{project_id}/similarity/queries/": {"get": {"operationId": "similarity_queries_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}}, "http://localhost:8000/{project_id}/similarity/queries/similarity": {"post": {"operationId": "similarity_queries_similarity_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "config_id", "required": true, "in": "formData", "description": "ID of the new NBLAST configuration to use", "type": "string"}, {"name": "query_ids", "required": true, "in": "formData", "description": "Set of objects (skeletons or point clouds) to query similarity for.", "type": "string"}, {"name": "target_ids", "required": true, "in": "formData", "description": "Set of objects (skeletons or point clouds) or point clouds to compare against.", "type": "string"}, {"name": "target_type", "required": false, "in": "formData", "description": "Type of target objects, 'skeleton' or 'pointcloud'.", "type": "string"}, {"name": "name", "required": false, "in": "formData", "description": "Name for the similarity lookup task", "type": "string"}, {"name": "normalized", "required": false, "in": "formData", "description": "Whether and how scores should be normalized.", "type": "string"}, {"name": "use_alpha", "required": false, "in": "formData", "description": "Whether to consider local directions in the similarity computation", "type": "string"}, {"name": "reverse", "required": false, "in": "formData", "description": "If enabled, the target is matched against the query.", "type": "string"}, {"name": "query_type_id", "required": false, "in": "formData", "description": "Type of query data", "type": "string"}, {"name": "target_type_id", "required": false, "in": "formData", "description": "Type of query data", "type": "string"}, {"name": "query_meta", "required": false, "in": "formData", "description": "Extra data for the selected query type. A JSON encoded string is expected.", "type": "string"}, {"name": "target_meta", "required": false, "in": "formData", "description": "Extra data for the selected target type. A JSON encoded string is expected.", "type": "string"}, {"name": "remove_target_duplicates", "required": false, "in": "formData", "description": "Remove all target objects that appear also in the query.", "type": "string"}, {"name": "simplify", "required": false, "in": "formData", "description": "Whether or not to simplify neurons and remove parts below a specified branch point level.", "type": "string"}, {"name": "required_branches", "required": false, "in": "formData", "description": "The required branch levels if neurons should be simplified.", "type": "string"}, {"name": "use_cache", "required": false, "in": "formData", "description": "Whether or not to use cached data when computing similarity scores.", "type": "string"}, {"name": "top_n", "required": false, "in": "formData", "description": "How many results should be returned sorted by score. A\nvalue of zero dsiables this cutoff.\n", "type": "string"}], "description": "Compare two sets of objects (skeletons or point clouds) and return an\nNBLAST scoring based on an existing NBLAST configuration.", "summary": "Compare two sets of objects (skeletons or point clouds) and return an", "consumes": ["application/x-www-form-urlencoded"], "tags": ["similarity"]}}, "http://localhost:8000/{project_id}/similarity/queries/{similarity_id}/": {"get": {"operationId": "similarity_queries_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "similarity_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}, "delete": {"operationId": "similarity_queries_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "similarity_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["similarity"]}}, "http://localhost:8000/{project_id}/skeleton/connectivity_matrix": {"post": {"operationId": "skeleton_connectivity_matrix_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of skeletons", "type": "string"}, {"name": "rows", "required": true, "in": "formData", "description": "IDs of row skeletons", "type": "string"}, {"name": "columns", "required": true, "in": "formData", "description": "IDs of column skeletons", "type": "string"}, {"name": "with_locations", "required": false, "in": "formData", "description": "Whether or not to return locations of connectors", "type": "string"}], "description": "Return a sparse connectivity matrix representation for the given skeleton\nIDs. The returned dictionary has a key for each row skeleton having\noutgoing connections to one or more column skeletons. Each entry stores a\ndictionary that maps the connection partners to the individual outgoing\nsynapse counts.", "summary": "Return a sparse connectivity matrix representation for the given skeleton", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeleton"]}}, "http://localhost:8000/{project_id}/skeleton/neuronnames": {"post": {"operationId": "skeleton_neuronnames_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to query name for", "type": "string"}], "description": "Map skeleton IDs to neuron base names.", "summary": "Map skeleton IDs to neuron base names.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeleton"]}}, "http://localhost:8000/{project_id}/skeleton/{skeleton_id}/eswc": {"get": {"operationId": "skeleton_eswc_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Export an extended SWC file. It includes a creation user name, creation\ntimestamp, editor user name and edition time stamp as well as a condidence\nvalue in range [0,5].", "summary": "Export an extended SWC file. It includes a creation user name, creation", "tags": ["skeleton"]}}, "http://localhost:8000/{project_id}/skeleton/{skeleton_id}/swc": {"get": {"operationId": "skeleton_swc_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Export a skeleton as standard SWC file.", "summary": "Export a skeleton as standard SWC file.", "tags": ["skeleton"]}}, "http://localhost:8000/{project_id}/skeletons/": {"get": {"operationId": "skeletons_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "created_by", "required": false, "in": "query", "description": "Filter for user ID of the skeletons' creator.", "type": "string"}, {"name": "reviewed_by", "required": false, "in": "query", "description": "Filter for user ID of the skeletons' reviewer.", "type": "string"}, {"name": "from_date", "required": false, "in": "query", "description": "Filter for skeletons with nodes created after this date.", "type": "string"}, {"name": "to_date", "required": false, "in": "query", "description": "Filter for skeletons with nodes created before this date.", "type": "string"}, {"name": "nodecount_gt", "required": false, "in": "query", "description": "Filter for skeletons with more nodes than this threshold. Removes\nall other criteria.\n", "type": "string"}], "description": "List skeletons matching filtering criteria.\n\nThe result set is the intersection of skeletons matching criteria (the\ncriteria are conjunctive) unless stated otherwise.", "summary": "List skeletons matching filtering criteria.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/cable-length": {"get": {"operationId": "skeletons_cable-length_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to query cable-length for", "type": "string"}], "description": "Get the cable length of a set of skeletons.\n\nReturns a mapping from skeleton ID to cable length.", "summary": "Get the cable length of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_cable-length_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to query cable-length for", "type": "string"}], "description": "Get the cable length of a set of skeletons.\n\nReturns a mapping from skeleton ID to cable length.", "summary": "Get the cable length of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/change-history": {"get": {"operationId": "skeletons_change-history_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "initial_user_id", "required": false, "in": "formData", "description": "User who caused the first change in all returned skeleton.", "type": "string"}, {"name": "changes_after", "required": false, "in": "formData", "description": "Date of format YYYY-MM-DDTHH:mm:ss, only the date part is required.\nLimits returns history to skeleton changes after this date.\n", "type": "string"}, {"name": "changes_before", "required": false, "in": "formData", "description": "Date of format YYYY-MM-DDTHH:mm:ss, only the date part is required.\nLimits returns history to skeleton changes before this date.\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Skeleton IDs of the initial set of treenodes.", "type": "string"}], "description": "Return the history of all skeletons ID changes in a project over time.\nOptionally, this can be constrained by a user ID and a time window.", "summary": "Return the history of all skeletons ID changes in a project over time.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/compact-detail": {"post": {"operationId": "skeletons_compact-detail_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "", "required": false, "in": "formData", "description": "", "type": "string"}, {"name": "with_connectors", "required": false, "in": "formData", "description": "Whether linked connectors should be returned.\n", "type": "string"}, {"name": "with_tags", "required": false, "in": "formData", "description": "Whether tags should be returned.\n", "type": "string"}, {"name": "with_history", "required": false, "in": "formData", "description": "Whether history information should be returned for each treenode and connector.\n", "type": "string"}, {"name": "with_merge_history", "required": false, "in": "formData", "description": "Whether the history of arbors merged into the requested skeleton should be returned. Only used if history is returned.\n", "type": "string"}, {"name": "with_reviews", "required": false, "in": "formData", "description": "Whether a node index should be returned that maps node IDs to the\nlist of reviews done on them, respects history parameter.\n", "type": "string"}, {"name": "with_annotations", "required": false, "in": "formData", "description": "Whether the list of linked annotations should be returned. If history\nshould be returned, returns all link versions.\n", "type": "string"}, {"name": "with_user_info", "required": false, "in": "formData", "description": "Whether all result elements should contain also the creator ID.\n", "type": "string"}], "description": "Get a compact treenode representation of a list of skeletons, optionally\nwith the history of individual nodes and connectors.\n\nReturns, in JSON, [[nodes], [connectors], {nodeID: [tags]}], with\nconnectors and tags being empty when 0 == with_connectors and 0 ==\nwith_tags, respectively.\n\nEach element in the [nodes] array has the following form:\n\n[skeleton_id, id, parent_id, user_id, location_x, location_y, location_z, radius, confidence].\n\nEach element in the [connectors] array has the following form, with the\nthird element representing the connector link as 0 = presynaptic, 1 =\npostsynaptic, 2 = gap junction, -1 = other:\n\n[treenode_id, connector_id, 0|1|2|-1, location_x, location_y, location_z]\n\nIf history data is requested, each row contains a validity interval. Note\nthat for the live table entry (the currently valid version), there are\nspecial semantics for this interval: The upper bound is older than or the\nsame as the lower bound. This is done to encode the information of this row\nbeing the most recent version and including the original creation time at\nthe same time, plus it requires less queries on the back-end to retireve\ndata. This requires the client to do slightly more work, but unfortunately\nthe original creation time is needed for data that was created without\nhistory tables enabled.", "summary": "Get a compact treenode representation of a list of skeletons, optionally", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/completeness": {"get": {"operationId": "skeletons_completeness_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Obtain completeness information for a set of skeleton IDs.", "summary": "Obtain completeness information for a set of skeleton IDs.", "tags": ["skeletons"]}, "post": {"operationId": "skeletons_completeness_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Obtain completeness information for a set of skeleton IDs.", "summary": "Obtain completeness information for a set of skeleton IDs.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/confidence-compartment-subgraph": {"post": {"operationId": "skeletons_confidence-compartment-subgraph_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to graph", "type": "string"}, {"name": "confidence_threshold", "required": false, "in": "formData", "description": "Confidence value below which to segregate compartments", "type": "string"}, {"name": "bandwidth", "required": false, "in": "formData", "description": "Bandwidth in nanometers", "type": "string"}, {"name": "cable_spread", "required": false, "in": "formData", "description": "Cable spread in nanometers", "type": "string"}, {"name": "expand[]", "required": false, "in": "formData", "description": "IDs of the skeletons to expand", "type": "string"}, {"name": "link_types[]", "required": false, "in": "formData", "description": "IDs of link types to respect", "type": "string"}, {"name": "allowed_connector_ids[]", "required": false, "in": "formData", "description": "(Optional) IDs of allowed conectors. All other connectors will be ignored.", "type": "string"}], "description": "Get a synaptic graph between skeletons compartmentalized by confidence.\n\nGiven a set of skeletons, retrieve presynaptic-to-postsynaptic edges\nbetween them, annotated with count. If a confidence threshold is\nsupplied, compartmentalize the skeletons at edges in the arbor\nbelow that threshold and report connectivity based on these\ncompartments.\n\nWhen skeletons are split into compartments, nodes in the graph take an\nstring ID like ``{skeleton_id}_{compartment #}``.", "summary": "Get a synaptic graph between skeletons compartmentalized by confidence.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/connectivity": {"post": {"operationId": "skeletons_connectivity_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "source_skeleton_ids", "required": true, "in": "formData", "description": "IDs of the skeletons whose partners to find", "type": "string"}, {"name": "boolean_op", "required": true, "in": "formData", "description": "Whether to find partners of any source skeleton (\"OR\") or partners\ncommon to all source skeletons (\"AND\")\n", "type": "string"}, {"name": "with_nodes", "required": false, "in": "formData", "description": "Whether to return detailed connectivity information that includes\npartner sites.\n", "type": "string"}, {"name": "link_types", "required": false, "in": "formData", "description": "A list of allowed link types: incoming, outgoing, abutting,\ngapjunction, tightjunction, desmosome, attachment, close_object.\n", "type": "string"}], "description": "Retrieve a list of down/up-stream partners of a set of skeletons.\n\nFrom a queried set of source skeletons, find all upstream and downstream\npartners, the number of synapses between each source and each partner,\nand a list of reviewers for each partner set. Confidence distributions for\neach synapse count are included. Optionally find only those partners\nthat are common between the source skeleton set.", "summary": "Retrieve a list of down/up-stream partners of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/connectivity-counts": {"get": {"operationId": "skeletons_connectivity-counts_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of work in", "type": "string"}, {"name": "count_partner_links", "required": false, "in": "path", "description": "Whether to count partner links or links to a connector.", "type": "string"}, {"name": "source_relations[]", "required": false, "in": "formData", "description": "A list of pre-connector relations that have to be used", "type": "string"}, {"name": "target_relations[]", "required": false, "in": "formData", "description": "A list of post-connector relations that have to be used", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons whose partners to count", "type": "string"}], "description": "Get the number of synapses per type for r a set of skeletons.\n\nReturns an object with to fields. The first, `connectivity`, is a mapping\nfrom skeleton ID to objects that map a relation ID to connectivity count for\nthat particular relation. The second field of the returned object,\n`relations`, maps relation IDs used in the first field to relation names.", "summary": "Get the number of synapses per type for r a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_connectivity-counts_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of work in", "type": "string"}, {"name": "count_partner_links", "required": false, "in": "path", "description": "Whether to count partner links or links to a connector.", "type": "string"}, {"name": "source_relations[]", "required": false, "in": "formData", "description": "A list of pre-connector relations that have to be used", "type": "string"}, {"name": "target_relations[]", "required": false, "in": "formData", "description": "A list of post-connector relations that have to be used", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons whose partners to count", "type": "string"}], "description": "Get the number of synapses per type for r a set of skeletons.\n\nReturns an object with to fields. The first, `connectivity`, is a mapping\nfrom skeleton ID to objects that map a relation ID to connectivity count for\nthat particular relation. The second field of the returned object,\n`relations`, maps relation IDs used in the first field to relation names.", "summary": "Get the number of synapses per type for r a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/connectivity_matrix/csv": {"post": {"operationId": "skeletons_connectivity_matrix_csv_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of skeletons", "type": "string"}, {"name": "rows", "required": true, "in": "formData", "description": "IDs of row skeletons", "type": "string"}, {"name": "columns", "required": true, "in": "formData", "description": "IDs of column skeletons", "type": "string"}, {"name": "names", "required": false, "in": "formData", "description": "An optional mapping of skeleton IDs versus names.\nRepresented as a list of two-element lists. Each inner list\nfollows the form [<skeleton-id>, <name>].\n", "type": "string"}], "description": "Return a CSV file that represents the connectivity matrix of a set of row\nskeletons and a set of column skeletons.", "summary": "Return a CSV file that represents the connectivity matrix of a set of row", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/from-origin": {"get": {"operationId": "skeletons_from-origin_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "source_ids[]", "required": true, "in": "formData", "description": "IDs of the source IDs to query origin for", "type": "string"}, {"name": "source_url", "required": true, "in": "path", "description": "Source URL of skeletons", "type": "string"}, {"name": "source_project_id", "required": true, "in": "path", "description": "Source project ID of skeletons", "type": "string"}], "description": "Find mappings to existing skeletons for potential imports.", "summary": "Find mappings to existing skeletons for potential imports.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_from-origin_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "source_ids[]", "required": true, "in": "formData", "description": "IDs of the source IDs to query origin for", "type": "string"}, {"name": "source_url", "required": true, "in": "path", "description": "Source URL of skeletons", "type": "string"}, {"name": "source_project_id", "required": true, "in": "path", "description": "Source project ID of skeletons", "type": "string"}], "description": "Find mappings to existing skeletons for potential imports.", "summary": "Find mappings to existing skeletons for potential imports.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/import": {"post": {"operationId": "skeletons_import_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "neuron_id", "required": false, "in": "formData", "description": "If specified a request for a particular neuron ID is expressed. If force = true, this request is enforced and the existing neuron ID (and all its skeletons) is replaced (as long as they are in the target project). If force = false (default), the neuron ID is only used if available and a new one is generated otherwise.\n", "type": "string"}, {"name": "skeleton_id", "required": false, "in": "formData", "description": "If specified a request for a particular skeleton ID is expressed. If force = true, this request is enforced and the existing skeleton ID (and all its neurons) is replaced (as long as they are in the target project). If force = false (default), the skeleton ID is only used if available and a new one is generated otherwise.\n", "type": "string"}, {"name": "force", "required": false, "in": "formData", "description": "If neuron_id or skeleton_id are passed in, existing neuron/skeleton instances in this project are replaced. All their respectively linked skeletons and neurons will be removed.\n", "type": "string"}, {"name": "auto_id", "required": false, "in": "formData", "description": "If a passed in neuron ID or skeleton ID is already in use, a new ID will be selected automatically (default). If auto_id is set to false, an error is raised in this situation.\n", "type": "string"}, {"name": "name", "required": false, "in": "formData", "description": "If specified, the name of a new neuron will be set to this.\n", "type": "string"}, {"name": "annotations", "required": false, "in": "formData", "description": "An optional list of annotation names that is added to the imported skeleton.\n", "type": "string"}, {"name": "source_id", "required": false, "in": "formData", "description": "If specified, this source ID will be saved and mapped to the new skeleton ID.\n", "type": "string"}, {"name": "source_project_id", "required": false, "in": "formData", "description": "If specified, this source project ID will be saved and mapped to the new skeleton ID. This is only valid together with source_id and source_url.\n", "type": "string"}, {"name": "source_url", "required": false, "in": "formData", "description": "If specified, this source URL will be saved and mapped to the new skeleton ID.\n", "type": "string"}, {"name": "source_type", "required": false, "in": "formData", "description": "Can be either 'skeleton' or 'segmentation', to further specify of what type the origin data is.\n", "type": "string"}, {"name": "file", "required": true, "in": "body", "description": "A skeleton representation file to import.", "schema": {}}], "description": "Import a neuron modeled by a skeleton from an uploaded file.\n\nCurrently only SWC and eSWC representation is supported.", "summary": "Import a neuron modeled by a skeleton from an uploaded file.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/import-info": {"get": {"operationId": "skeletons_import-info_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of skeletons to get import information for.", "type": "string"}, {"name": "with_treenodes", "required": false, "in": "formData", "description": "Whether to include IDs of all imported nodes in response.", "type": "string"}], "description": "Get information on imported nodes of a set of skeletons.", "summary": "Get information on imported nodes of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_import-info_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of skeletons to get import information for.", "type": "string"}, {"name": "with_treenodes", "required": false, "in": "formData", "description": "Whether to include IDs of all imported nodes in response.", "type": "string"}], "description": "Get information on imported nodes of a set of skeletons.", "summary": "Get information on imported nodes of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/in-bounding-box": {"get": {"operationId": "skeletons_in-bounding-box_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "limit", "required": false, "in": "formData", "description": "Limit the number of returned nodes.\n", "type": "string"}, {"name": "minx", "required": true, "in": "formData", "description": "Minimum world space X coordinate\n", "type": "string"}, {"name": "miny", "required": true, "in": "formData", "description": "Minimum world space Y coordinate\n", "type": "string"}, {"name": "minz", "required": true, "in": "formData", "description": "Minimum world space Z coordinate\n", "type": "string"}, {"name": "maxx", "required": true, "in": "formData", "description": "Maximum world space X coordinate\n", "type": "string"}, {"name": "maxy", "required": true, "in": "formData", "description": "Maximum world space Y coordinate\n", "type": "string"}, {"name": "maxz", "required": true, "in": "formData", "description": "Maximum world space Z coordinate\n", "type": "string"}, {"name": "min_nodes", "required": false, "in": "formData", "description": "A minimum number of nodes per result skeleton\n", "type": "string"}, {"name": "min_cable", "required": false, "in": "formData", "description": "A minimum number of cable length per result skeleton\n", "type": "string"}, {"name": "volume_id", "required": false, "in": "formData", "description": "Alternative to manual bounding box definition. The bounding box of the\nvolume is used.\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "An optional list of skeleton IDs that should only be tested againt. If\nused, the result will only contain skeletons of this set.\n", "type": "string"}], "description": "Get a list of all skeletons that intersect with the passed in bounding\nbox. Optionally, only a subsed of passed in skeletons can be tested against.", "summary": "Get a list of all skeletons that intersect with the passed in bounding", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_in-bounding-box_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "limit", "required": false, "in": "formData", "description": "Limit the number of returned nodes.\n", "type": "string"}, {"name": "minx", "required": true, "in": "formData", "description": "Minimum world space X coordinate\n", "type": "string"}, {"name": "miny", "required": true, "in": "formData", "description": "Minimum world space Y coordinate\n", "type": "string"}, {"name": "minz", "required": true, "in": "formData", "description": "Minimum world space Z coordinate\n", "type": "string"}, {"name": "maxx", "required": true, "in": "formData", "description": "Maximum world space X coordinate\n", "type": "string"}, {"name": "maxy", "required": true, "in": "formData", "description": "Maximum world space Y coordinate\n", "type": "string"}, {"name": "maxz", "required": true, "in": "formData", "description": "Maximum world space Z coordinate\n", "type": "string"}, {"name": "min_nodes", "required": false, "in": "formData", "description": "A minimum number of nodes per result skeleton\n", "type": "string"}, {"name": "min_cable", "required": false, "in": "formData", "description": "A minimum number of cable length per result skeleton\n", "type": "string"}, {"name": "volume_id", "required": false, "in": "formData", "description": "Alternative to manual bounding box definition. The bounding box of the\nvolume is used.\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "An optional list of skeleton IDs that should only be tested againt. If\nused, the result will only contain skeletons of this set.\n", "type": "string"}], "description": "Get a list of all skeletons that intersect with the passed in bounding\nbox. Optionally, only a subsed of passed in skeletons can be tested against.", "summary": "Get a list of all skeletons that intersect with the passed in bounding", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/node-labels": {"get": {"operationId": "skeletons_node-labels_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "label_ids[]", "required": true, "in": "formData", "description": "IDs of the labels to find skeletons associated with", "type": "string"}, {"name": "label_names[]", "required": true, "in": "formData", "description": "Alternative to `label_ids` to pass in a list label names.", "type": "string"}], "description": "Return relationship between label IDs and skeleton IDs", "summary": "Return relationship between label IDs and skeleton IDs", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_node-labels_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "label_ids[]", "required": true, "in": "formData", "description": "IDs of the labels to find skeletons associated with", "type": "string"}, {"name": "label_names[]", "required": true, "in": "formData", "description": "Alternative to `label_ids` to pass in a list label names.", "type": "string"}], "description": "Return relationship between label IDs and skeleton IDs", "summary": "Return relationship between label IDs and skeleton IDs", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/origin": {"get": {"operationId": "skeletons_origin_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of skeletons to get origin for", "type": "string"}], "description": "Get origin information of a set of skeletons.", "summary": "Get origin information of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_origin_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of skeletons to get origin for", "type": "string"}], "description": "Get origin information of a set of skeletons.", "summary": "Get origin information of a set of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/review-status": {"post": {"operationId": "skeletons_review-status_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to retrieve.", "type": "string"}, {"name": "whitelist", "required": false, "in": "formData", "description": "ID of the user whose reviewer team to use to filter reviews\n(exclusive to user_ids)\n", "type": "string"}, {"name": "user_ids[]", "required": false, "in": "formData", "description": "IDs of the users whose reviews should be counted (exclusive\nto whitelist)\n", "type": "string"}], "description": "Retrieve the review status for a collection of skeletons.\n\nThe review status for each skeleton in the request is a tuple of total\nnodes and number of reviewed nodes (integers). The reviews of only\ncertain users or a reviewer team may be counted instead of all reviews.", "summary": "Retrieve the review status for a collection of skeletons.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/sampler-count": {"post": {"operationId": "skeletons_sampler-count_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of skeleton", "type": "string"}, {"name": "skeleton_ids", "required": true, "in": "path", "description": "IDs of the skeleton to get the sampler count for.", "type": "string"}], "description": "Get the number of samplers associated with each skeleton in the passed in\nlast.", "summary": "Get the number of samplers associated with each skeleton in the passed in", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/summary": {"get": {"operationId": "skeletons_summary_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to query summary for.", "type": "string"}], "description": "Get the original creation time, last edit time, number of nodes, number\nof imported nodes, cable length and last editor information for a list\nskeleton IDs.\n\nReturns a mapping from skeleton ID to summary info", "summary": "Get the original creation time, last edit time, number of nodes, number", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_summary_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons to query summary for.", "type": "string"}], "description": "Get the original creation time, last edit time, number of nodes, number\nof imported nodes, cable length and last editor information for a list\nskeleton IDs.\n\nReturns a mapping from skeleton ID to summary info", "summary": "Get the original creation time, last edit time, number of nodes, number", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/validity": {"get": {"operationId": "skeletons_validity_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of landmark", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons whose partners to find", "type": "string"}, {"name": "return_invalid", "required": false, "in": "formData", "description": "Whether or not to return invalid skeleton IDs rather than valid ones.", "type": "string"}], "description": "Find out if passed skeleton IDs are valid (and represent present\nskeletons).\n\nReturns all passed in skeletons that are valid.", "summary": "Find out if passed skeleton IDs are valid (and represent present", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}, "post": {"operationId": "skeletons_validity_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of landmark", "type": "string"}, {"name": "skeleton_ids[]", "required": true, "in": "formData", "description": "IDs of the skeletons whose partners to find", "type": "string"}, {"name": "return_invalid", "required": false, "in": "formData", "description": "Whether or not to return invalid skeleton IDs rather than valid ones.", "type": "string"}], "description": "Find out if passed skeleton IDs are valid (and represent present\nskeletons).\n\nReturns all passed in skeletons that are valid.", "summary": "Find out if passed skeleton IDs are valid (and represent present", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/within-spatial-distance": {"post": {"operationId": "skeletons_within-spatial-distance_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "formData", "description": "ID of the origin treenode to search around", "type": "string"}, {"name": "distance", "required": false, "in": "formData", "description": "L-infinity distance in nanometers within which to search", "type": "string"}, {"name": "size_mode", "required": false, "in": "formData", "description": "Whether to return skeletons with only one node in the search area\n(1) or more than one node in the search area (0).\n", "type": "string"}], "description": "Find skeletons within a given L-infinity distance of a treenode.\n\nReturns at most 100 results.", "summary": "Find skeletons within a given L-infinity distance of a treenode.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/cable-length": {"get": {"operationId": "skeletons_cable-length_list_0", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of landmark", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "IDs of the skeleton to get the cable length for", "type": "string"}], "description": "Get the cable length for a skeleton", "summary": "Get the cable length for a skeleton", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/compact-detail": {"get": {"operationId": "skeletons_compact-detail_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "with_connectors", "required": false, "in": "formData", "description": "Whether linked connectors should be returned.\n", "type": "string"}, {"name": "with_tags", "required": false, "in": "formData", "description": "Whether tags should be returned.\n", "type": "string"}, {"name": "with_history", "required": false, "in": "formData", "description": "Whether history information should be returned for each treenode and\nconnector.\n", "type": "string"}, {"name": "with_merge_history", "required": false, "in": "formData", "description": "Whether the history of arbors merged into the requested skeleton should\nbe returned. Only used if history is returned.\n", "type": "string"}, {"name": "with_reviews", "required": false, "in": "formData", "description": "Whether a node index should be returned that maps node IDs to the\nlist of reviews done on them, respects history parameter.\n", "type": "string"}, {"name": "with_annotations", "required": false, "in": "formData", "description": "Whether the list of linked annotations should be returned. If history\nshould be returned, returns all link versions.\n", "type": "string"}, {"name": "with_user_info", "required": false, "in": "formData", "description": "Whether all result elements should contain also the creator ID.\n", "type": "string"}, {"name": "ordered", "required": false, "in": "formData", "description": "Whether result skeletons should be ordered by ID.\n", "type": "string"}], "description": "Get a compact treenode representation of a skeleton, optionally with the\nhistory of individual nodes and connectors.\n\nReturns, in JSON, [[nodes], [connectors], {nodeID: [tags]}], with\nconnectors and tags being empty when 0 == with_connectors and 0 ==\nwith_tags, respectively.\n\nEach element in the [nodes] array has the following form:\n\n[id, parent_id, user_id, location_x, location_y, location_z, radius, confidence].\n\nEach element in the [connectors] array has the following form, with the\nthird element representing the connector link as 0 = presynaptic, 1 =\npostsynaptic, 2 = gap junction, -1 = other:\n\n[treenode_id, connector_id, 0|1|2|-1, location_x, location_y, location_z]\n\nIf history data is requested, each row contains a validity interval. Note\nthat for the live table entry (the currently valid version), there are\nspecial semantics for this interval: The upper bound is older than or the\nsame as the lower bound. This is done to encode the information of this row\nbeing the most recent version and including the original creation time at\nthe same time, plus it requires less queries on the back-end to retireve\ndata. This requires the client to do slightly more work, but unfortunately\nthe original creation time is needed for data that was created without\nhistory tables enabled.", "summary": "Get a compact treenode representation of a skeleton, optionally with the", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/find-labels": {"post": {"operationId": "skeletons_find-labels_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "formData", "description": "ID of the origin treenode for path length distances", "type": "string"}, {"name": "label_regex", "required": true, "in": "formData", "description": "Regular expression query to match labels", "type": "string"}, {"name": "only_leaves", "required": false, "in": "formData", "description": "Whether to only return information on leaf nodes.", "type": "string"}], "description": "List nodes in a skeleton with labels matching a query.\n\nFind all nodes in this skeleton with labels (front-end node tags) matching\na regular expression, sort them by ascending path distance from a treenode\nin the skeleton, and return the result.", "summary": "List nodes in a skeleton with labels matching a query.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/neuroglancer": {"get": {"operationId": "skeletons_neuroglancer_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Export a morphology-only skeleton in neuroglancer's binary format.", "summary": "Export a morphology-only skeleton in neuroglancer's binary format.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/node-overview": {"get": {"operationId": "skeletons_node-overview_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "The skeleton to get information on", "type": "string"}], "description": "Get information on a skeleton's treenodes, reviews and labels.", "summary": "Get information on a skeleton's treenodes, reviews and labels.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/open-leaves": {"post": {"operationId": "skeletons_open-leaves_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "formData", "description": "ID of the origin treenode for path length distances", "type": "string"}], "description": "List open leaf nodes in a skeleton.\n\nReturn a list of the ID and location of open leaf nodes in a skeleton,\ntheir path length distance to the specified treenode, and their creation\ntime.\n\nLeaves are considered open if they are not tagged with a tag matching\na particular regex.\n\n.. note:: This endpoint is used interactively by the client so performance\nis critical.", "summary": "List open leaf nodes in a skeleton.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/review": {"post": {"operationId": "skeletons_review_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "subarbor_node_id", "required": false, "in": "formData", "description": "If provided, only the subarbor starting at this treenode is returned.\n", "type": "string"}], "description": "Export skeleton as a set of segments with per-node review information.\n\nExport the skeleton as a list of segments of non-branching node paths,\nwith detailed information on reviewers and review times for each node.", "summary": "Export skeleton as a set of segments with per-node review information.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/root": {"get": {"operationId": "skeletons_root_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Retrieve ID and location of the skeleton's root treenode.", "summary": "Retrieve ID and location of the skeleton's root treenode.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/skeletons/{skeleton_id}/sampler-count": {"get": {"operationId": "skeletons_sampler-count_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project of skeleton", "type": "string"}, {"name": "skeleton_id", "required": true, "in": "path", "description": "ID of the skeleton to get the sampler count for.", "type": "string"}], "description": "Get the number of samplers associated with this skeleton.", "summary": "Get the number of samplers associated with this skeleton.", "tags": ["skeletons"]}}, "http://localhost:8000/{project_id}/stats/cable-length": {"get": {"operationId": "stats_cable-length_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get the largest skeletons based on cable length.", "summary": "Get the largest skeletons based on cable length.", "tags": ["stats"]}}, "http://localhost:8000/{project_id}/stats/editor": {"get": {"operationId": "stats_editor_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Get the total number of edited nodes per user.", "summary": "Get the total number of edited nodes per user.", "tags": ["stats"]}}, "http://localhost:8000/{project_id}/stats/nodecount": {"get": {"operationId": "stats_nodecount_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "with_imports", "required": false, "in": "formData", "description": "Whether data added through imports should be respected.\n", "type": "string"}], "description": "Get the total number of created nodes per user.", "summary": "Get the total number of created nodes per user.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["stats"]}}, "http://localhost:8000/{project_id}/stats/server": {"get": {"operationId": "stats_server_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["stats"]}}, "http://localhost:8000/{project_id}/stats/user-history": {"get": {"operationId": "stats_user-history_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "start_date", "required": false, "in": "formData", "description": "If provided (YYYY-MM-DD), only statistics from this day on are returned (inclusive).\n", "type": "string"}, {"name": "end_date", "required": false, "in": "formData", "description": "If provided (YYYY-MM-DD), only statistics to this day on are returned (inclusive).\n", "type": "string"}, {"name": "time_zone", "required": false, "in": "formData", "description": "Optional time zone for the date range, e.g. \"US/Eastern\"\n", "type": "string"}, {"name": "with_imports", "required": false, "in": "formData", "description": "Whether or not to return information on the imported number of nodes and\ncable length.\n", "type": "string"}], "description": "Get per user contribution statistics\n\nA date range can be provided to limit the scope of the returned statiscis.\nBy default, the statistics for the last ten days is returned. The returned\ndata includes created cable length, the number of created synaptic\nconnections and the number of reviews made, per day and user.", "summary": "Get per user contribution statistics", "consumes": ["application/x-www-form-urlencoded"], "tags": ["stats"]}}, "http://localhost:8000/{project_id}/transactions/": {"get": {"operationId": "transactions_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "range_start", "required": false, "in": "formData", "description": "The first result element index.", "type": "string"}, {"name": "range_length", "required": false, "in": "formData", "description": "The maximum number result elements.", "type": "string"}], "description": "Get a collection of all available transactions in the passed in project.", "summary": "Get a collection of all available transactions in the passed in project.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["transactions"]}}, "http://localhost:8000/{project_id}/transactions/location": {"get": {"operationId": "transactions_location_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "transaction_id", "required": true, "in": "formData", "description": "Transaction ID in question", "type": "string"}, {"name": "execution_time", "required": true, "in": "formData", "description": "Execution time of the transaction", "type": "string"}, {"name": "label", "required": false, "in": "formData", "description": "Optional label of the transaction to avoid extra lookup", "type": "string"}], "description": "Try to associate a location in the passed in project for a particular\ntransaction.", "summary": "Try to associate a location in the passed in project for a particular", "consumes": ["application/x-www-form-urlencoded"], "tags": ["transactions"]}}, "http://localhost:8000/{project_id}/treenodes/compact-detail": {"post": {"operationId": "treenodes_compact-detail_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "formData", "description": "Project to work in", "type": "string"}, {"name": "treenode_ids", "required": false, "in": "formData", "description": "A list of treeonde IDs to return information on", "type": "string"}, {"name": "label_ids", "required": false, "in": "formData", "description": "A list of label IDs that must be linked to result treenodes. Alternative\nto explicit treenode IDs and label names.\n", "type": "string"}, {"name": "label_names", "required": false, "in": "formData", "description": "A list of label names that must be linked to result treenodes.\nAlternative to explicit treenode IDs and label IDs\n", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "A list of skeleton IDs that result skeletons have to be part of.\n", "type": "string"}], "description": "Retrieve node information in a compact form. A list of elements of the\nfollowing form is returned:\n\n[ID, parent ID, x, y, z, confidence, radius, skeleton_id, edition_time, user_id]\n\nThe returned edition time is an epoch number.", "summary": "Retrieve node information in a compact form. A list of elements of the", "consumes": ["application/x-www-form-urlencoded"], "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/compact-detail": {"get": {"operationId": "treenodes_compact-detail_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Retrieve node information in a compact form. A list of the following form\nis returned:\n\n[ID, parent ID, x, y, z, confidence, radius, skeleton_id, edition_time, user_id]\n\nThe returned edition time is an epoch number.", "summary": "Retrieve node information in a compact form. A list of the following form", "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/confidence": {"post": {"operationId": "treenodes_confidence_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "new_confidence", "required": true, "in": "formData", "description": "New confidence, value in range 1-5", "type": "string"}, {"name": "to_connector", "required": false, "in": "formData", "description": "Whether all linked connectors instead of parent should be updated", "type": "string"}, {"name": "partner_ids", "required": false, "in": "formData", "description": "Limit update to a set of connectors if to_connector is true", "type": "string"}, {"name": "partner_confidences", "required": false, "in": "formData", "description": "Set different confidences to connectors in <partner_ids>", "type": "string"}], "description": "Update confidence of edge between a node to either its parent or its\nconnectors.\n\nThe connection between a node and its parent or the connectors it is linked\nto can be rated with a confidence value in the range 1-5. If connector links\nshould be updated, one can limit the affected connections to a specific\nconnector. Returned is an object, mapping updated partners to their old\nconfidences.", "summary": "Update confidence of edge between a node to either its parent or its", "consumes": ["application/x-www-form-urlencoded"], "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/importing-user": {"get": {"operationId": "treenodes_importing-user_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Retrieve the user ID of the user who imported the passed in treenode. If\nthis node wasn't imported, return None.", "summary": "Retrieve the user ID of the user who imported the passed in treenode. If", "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/info": {"get": {"operationId": "treenodes_info_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Retrieve skeleton and neuron information about this treenode.", "summary": "Retrieve skeleton and neuron information about this treenode.", "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/suppressed-virtual/": {"get": {"operationId": "treenodes_suppressed-virtual_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["treenodes"]}, "post": {"operationId": "treenodes_suppressed-virtual_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/treenodes/{treenode_id}/suppressed-virtual/{suppressed_id}": {"delete": {"operationId": "treenodes_suppressed-virtual_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "treenode_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "suppressed_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["treenodes"]}}, "http://localhost:8000/{project_id}/volumes/": {"get": {"operationId": "volumes_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "volume_ids", "required": false, "in": "formData", "description": "Only return specified volumes", "type": "string"}], "description": "Get a collection of all available volumes.", "summary": "Get a collection of all available volumes.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}, "post": {"operationId": "volumes_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "Project to operate in", "type": "string"}, {"name": "volume_ids", "required": false, "in": "formData", "description": "Only return specified volumes", "type": "string"}], "description": "Get a collection of all available volumes.", "summary": "Get a collection of all available volumes.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/add": {"post": {"operationId": "volumes_add_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "type", "required": true, "in": "formData", "description": "Type of volume to create", "type": "string"}, {"name": "title", "required": true, "in": "formData", "description": "Title of volume", "type": "string"}, {"name": "comment", "required": false, "in": "formData", "description": "An optional comment", "type": "string"}, {"name": "mesh", "required": false, "in": "formData", "description": "Triangle mesh", "type": "string"}, {"name": "minx", "required": false, "in": "formData", "description": "Minimum x coordinate of box", "type": "string"}, {"name": "miny", "required": false, "in": "formData", "description": "Minimum y coordinate of box", "type": "string"}, {"name": "minz", "required": false, "in": "formData", "description": "Minimum z coordinate of box", "type": "string"}, {"name": "maxx", "required": false, "in": "formData", "description": "Maximum x coordinate of box", "type": "string"}, {"name": "maxy", "required": false, "in": "formData", "description": "Maximum y coordinate of box", "type": "string"}, {"name": "maxz", "required": false, "in": "formData", "description": "Maximum z coordinate of box", "type": "string"}], "description": "Create a new volume\n\nThe ID of the newly created volume is returned. Currently, box volumes and\ntriangle meshes are supported. Which one is created depends on the \"type\"\nparameter, which can be either set to \"box\" or to \"trimesh\".\n\nIf a triangle mesh should be created, the \"mesh\" parameter is expected to\nhold the complete volume. It is expected to be a string that encodes two\nlists in JSON format: [[points], [triangles]]. The list of points contains\nlists of three numbers, each one representing a vertex in the mesh. The\narray of triangles also contains three element lists as items. Each one\nrepresents a triangle based on the points in the other array, that are\nreferenced by the triangle index values.", "summary": "Create a new volume", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/entities/": {"post": {"operationId": "volumes_entities_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_ids", "required": false, "in": "query", "description": "A list of volume IDs to map", "type": "string"}], "description": "Retrieve a mapping of volume IDs to entity (class instance) IDs.", "summary": "Retrieve a mapping of volume IDs to entity (class instance) IDs.", "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/import": {"post": {"operationId": "volumes_import_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "file", "required": true, "in": "body", "description": "Triangle mesh file to import. Multiple files can be provided, with each being imported as a mesh named by its base filename.\n", "schema": {}}], "description": "Import triangle mesh volumes from an uploaded files.\n\nCurrently only STL representation is supported.", "summary": "Import triangle mesh volumes from an uploaded files.", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/skeleton-innervations": {"get": {"operationId": "volumes_skeleton-innervations_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Constrain results to these skeletons", "type": "string"}, {"name": "annotation", "required": false, "in": "formData", "description": "An annotation potential target volumes need to have", "type": "string"}, {"name": "min_nodes", "required": false, "in": "formData", "description": "A minimum number of nodes result skeleton need to have.", "type": "string"}, {"name": "min_cable", "required": false, "in": "formData", "description": "A minimum number of cable length esult skeleton need to have.", "type": "string"}], "description": "Test environment only contains two skeletons - based on that, sql query\nalways returns list of all SKIDs but all data (about both skeletons) is\ncontained in the first SKID in the list - if this changes, write an else\nstatement for: len(cleanResults) >1.", "summary": "Test environment only contains two skeletons - based on that, sql query", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}, "post": {"operationId": "volumes_skeleton-innervations_create", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in", "type": "string"}, {"name": "skeleton_ids", "required": false, "in": "formData", "description": "Constrain results to these skeletons", "type": "string"}, {"name": "annotation", "required": false, "in": "formData", "description": "An annotation potential target volumes need to have", "type": "string"}, {"name": "min_nodes", "required": false, "in": "formData", "description": "A minimum number of nodes result skeleton need to have.", "type": "string"}, {"name": "min_cable", "required": false, "in": "formData", "description": "A minimum number of cable length esult skeleton need to have.", "type": "string"}], "description": "Test environment only contains two skeletons - based on that, sql query\nalways returns list of all SKIDs but all data (about both skeletons) is\ncontained in the first SKID in the list - if this changes, write an else\nstatement for: len(cleanResults) >1.", "summary": "Test environment only contains two skeletons - based on that, sql query", "consumes": ["application/x-www-form-urlencoded"], "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/{volume_id}/": {"get": {"operationId": "volumes_read", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["volumes"]}, "post": {"operationId": "volumes_create_0", "responses": {"201": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["volumes"]}, "delete": {"operationId": "volumes_delete", "responses": {"204": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "", "type": "string"}], "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/{volume_id}/export\\.{extension}": {"get": {"operationId": "volumes_read_0", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "extension", "required": true, "in": "path", "description": "", "type": "string"}], "description": "Export volume as a triangle mesh file.\n\nThe extension of the endpoint and `ACCEPT` header media type are both used\nto determine the format of the export.\n\nSupported formats by extension and media type:\n##### STL\n- `model/stl`, `model/x.stl-ascii`: ASCII STL", "summary": "Export volume as a triangle mesh file.", "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/{volume_id}/intersect": {"get": {"operationId": "volumes_intersect_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "", "type": "string"}, {"name": "x", "required": false, "in": "query", "description": "X coordinate of point to test", "type": "string"}, {"name": "y", "required": false, "in": "query", "description": "Y coordinate of point to test", "type": "string"}, {"name": "z", "required": false, "in": "query", "description": "Z coordinate of point to test", "type": "string"}], "description": "Test if a point intersects with the bounding box of a given volume.", "summary": "Test if a point intersects with the bounding box of a given volume.", "tags": ["volumes"]}}, "http://localhost:8000/{project_id}/volumes/{volume_id}/update-meta-info": {"get": {"operationId": "volumes_update-meta-info_list", "responses": {"200": {"description": ""}}, "parameters": [{"name": "project_id", "required": true, "in": "path", "description": "The project to operate in", "type": "string"}, {"name": "volume_id", "required": true, "in": "path", "description": "The volume to update", "type": "string"}], "description": "Update the meta data on all passed in volumes. This includes: area,\nvolume and watertightness.", "summary": "Update the meta data on all passed in volumes. This includes: area,", "tags": ["volumes"]}}}}
